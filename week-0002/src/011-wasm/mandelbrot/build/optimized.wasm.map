{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","assembly/index.ts"],"names":[],"mappings":"wGEUE,AAAiB,AAAC,GAAI,AAFL,GAAU,WAES,AADnB,SAAO,AAAI,AAAI,EAAJ,KAAW,AAAI,EAAJ,kBAEvC,AAAiB,AAJA,GAAU,UAIG,KAC9B,AAAiB,AAAC,EAAI,GAAU,KAChC,AAAiB,SAAM,MAEvB,AAAoB,AAAI,YAEnB,AAAa,MAAG,EAAI,KACvB,AAAW,GAAI,GAAQ,KAGd,aACT,AAAqB,MACd,AAAC,AAAO,EAAK,KAAO,AAAO,EAAK,MAAO,YAA9C,EACE,AAAK,SAAM,GAAK,GAAK,KACrB,AAAK,EAAO,GAAO,KACnB,AAAI,EAAa,KACjB,AAAE,cAIJ,AAAO,EAAY,KACjB,AAAY,EAAK,GAAK,EAAK,IAAK,KAChC,AAAK,SAAM,GAAK,GAAK,KACrB,AAAK,IACL,AAAE,WAYJ,AAAW,AAAU,EAAK,GAAf,GAJX,AAAI,AADM,EAAK,GAAK,EAAK,MACf,YAEF,SAAyB,AASxB,AAAI,AATgC,EAAY,IAAI,AADtC,SAAM,AAAS,QAC+B,GASjD,UAAW,oBArCD,AAAE","sourceRoot":"./optimized.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n\n// ╒════════════════ Common block layout (32-bit) ═════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                           GC info                             │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                          runtime id                           │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                         runtime size                          │ -4\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                              ...                              │ ref\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize; // WASM64 needs adaption\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags;\n  /** Base class id or `0` if none. */\n  base: u32;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `Set`. */\n  SET = 1 << 2,\n  /** Type is a `Map`. */\n  MAP = 1 << 3,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 4,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 5,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 6,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 7,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 8,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 9,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 10,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 11,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 12,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 13,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 14,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 15,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 16,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 17,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 18,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 19,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 20,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 21,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 22\n}\n","// see: https://en.wikipedia.org/wiki/Mandelbrot_set\n\n/** Number of discrete color values on the JS side. */\nconst NUM_COLORS = 2048;\n\n/** Computes a single line in the rectangle `width` x `height`. */\nexport function computeLine(y: u32, width: u32, height: u32, limit: u32): void {\n  var translateX = width  * (1.0 / 1.6);\n  var translateY = height * (1.0 / 2.0);\n  var scale      = 10.0 / min(3 * width, 4 * height);\n  var imaginary  = (y - translateY) * scale;\n  var realOffset = translateX * scale;\n  var stride     = (y * width) << 1;\n  var invLimit   = 1.0 / limit;\n\n  var minIterations = min(8, limit);\n\n  for (let x: u32 = 0; x < width; ++x) {\n    let real = x * scale - realOffset;\n\n    // Iterate until either the escape radius or iteration limit is exceeded\n    let ix = 0.0, iy = 0.0, ixSq: f64, iySq: f64;\n    let iteration: u32 = 0;\n    while ((ixSq = ix * ix) + (iySq = iy * iy) <= 4.0) {\n      iy = 2.0 * ix * iy + imaginary;\n      ix = ixSq - iySq + real;\n      if (iteration >= limit) break;\n      ++iteration;\n    }\n\n    // Do a few extra iterations for quick escapes to reduce error margin\n    while (iteration < minIterations) {\n      let ixNew = ix * ix - iy * iy + real;\n      iy = 2.0 * ix * iy + imaginary;\n      ix = ixNew;\n      ++iteration;\n    }\n\n    // Iteration count is a discrete value in the range [0, limit] here, but we'd like it to be\n    // normalized in the range [0, 2047] so it maps to the gradient computed in JS.\n    // see also: http://linas.org/art-gallery/escape/escape.html\n    let col = NUM_COLORS - 1;\n    let sqd = ix * ix + iy * iy;\n    if (sqd > 1.0) {\n      let frac = Math.log2(0.5 * Math.log(sqd));\n      col = <u32>((NUM_COLORS - 1) * clamp<f64>((iteration + 1 - frac) * invLimit, 0.0, 1.0));\n    }\n    store<u16>(stride + (x << 1), col);\n  }\n}\n\n/** Clamps a value between the given minimum and maximum. */\n@inline\nfunction clamp<T>(value: T, minValue: T, maxValue: T): T {\n  return min(max(value, minValue), maxValue);\n}\n"]}