{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","assembly/index.ts"],"names":[],"mappings":"qME4BE,AAAI,IACJ,AAAI,IACJ,AAAI,EAAQ,KAGP,AAAQ,QAAG,EAAI,WACb,AAAQ,QAAG,EAAI,aACd,IAAG,IAAG,EAAgB,YAAM,EAAW,OAAa,EAAY,SAnBxE,AAAW,AAAC,EAAI,EAAI,IAAI,GAAM,GAAG,OAkBR,AAAE,aADJ,AAAE,kBASf,EAAI,KACJ,EAAI,KAIT,AAAQ,QAAG,EAAI,WACR,EAAK,KAAI,GAAM,EAAI,MACnB,EAAK,KAAM,GAAI,EAAI,MACxB,AAAQ,QAAG,EAAI,WACR,EAAK,KAAI,GAAM,EAAI,MACnB,EAAK,KAAM,GAAI,EAAI,MAI7B,AACE,AAAC,EAAI,IAAK,mBAAO,GAAM,EAAI,IAAK,mBAAO,IAAM,EAAI,IAAK,mBAAO,IAC5D,EAAI,IAAK,mBAAO,IAA4B,EAAI,IAAK,mBAAO,IAC5D,EAAI,IAAK,mBAAO,IAAM,EAAI,IAAK,mBAAO,IAAM,EAAI,IAAK,mBAAO,MAG/D,AAAW,EAAI,IAAG,IApDtB,AAAiB,AAAC,EAAI,GAAI,GAAM,SAqD5B,AAAI,EAAO,KAET,AAAI,AAAC,EAAiB,GAAW,KAAY,IAAG,IAAG,yEAE1C,IAAG,IAAG,EAAW,6BAG1B,AAAI,EAAkB,KAAO,IAAG,IAAG,EAAY,4BAEtC,IAAG,IAAG,IAlDrB,AAAQ,AAAS,AAAC,EAAM,GAAM,KAAS,YACvC,EAAI,IAAG,IAAG,AAAC,EAAK,GAAO,EAAI,SAP3B,AAAW,AAAC,EAAI,EAAI,IAAI,GAAM,GAAG,SAkCR,AAAE,aAHJ,AAAE,kBAiCpB,AAAS,QAAG,EAAK,WACpB,AAAI,EAAgB,KAAO,IAAI,IAAG,EAAY,6BADvB,AAAE,YAGtB,AAAS,QAAG,EAAK,WACpB,AAAI,EAAgB,KAAO,IAAG,IAAI,EAAY,QApEhD,AAAW,AAAC,EAAI,EAAI,IAAI,GAAM,GAAG,OAmER,AAAE","sourceRoot":"./untouched.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n\n// ╒════════════════ Common block layout (32-bit) ═════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                           GC info                             │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                          runtime id                           │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                         runtime size                          │ -4\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                              ...                              │ ref\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize; // WASM64 needs adaption\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags;\n  /** Base class id or `0` if none. */\n  base: u32;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `Set`. */\n  SET = 1 << 2,\n  /** Type is a `Map`. */\n  MAP = 1 << 3,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 4,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 5,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 6,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 7,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 8,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 9,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 10,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 11,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 12,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 13,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 14,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 15,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 16,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 17,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 18,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 19,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 20,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 21,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 22\n}\n","// see: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\n\n// Configuration imported from JS\nimport { BGR_ALIVE, BGR_DEAD, BIT_ROT } from \"./config\";\n\nvar w: i32, h: i32, s: i32;\n\n/** Gets an input pixel in the range [0, s]. */\n@inline\nfunction get(x: u32, y: u32): u32 {\n  return load<u32>((y * w + x) << 2);\n}\n\n/** Sets an output pixel in the range [s, 2*s]. */\n@inline\nfunction set(x: u32, y: u32, v: u32): void {\n  store<u32>((s + y * w + x) << 2, v);\n}\n\n/** Sets an output pixel in the range [s, 2*s] while fading it out. */\n@inline\nfunction rot(x: u32, y: u32, v: u32): void {\n  var a = max<i32>((v >>> 24) - BIT_ROT, 0);\n  set(x, y, (a << 24) | (v & 0x00ffffff));\n}\n\n/** Initializes width and height. Called once from JS. */\nexport function init(width: i32, height: i32): void {\n  w = width;\n  h = height;\n  s = width * height;\n\n  // Start by filling output with random live cells.\n  for (let y = 0; y < h; ++y) {\n    for (let x = 0; x < w; ++x) {\n      set(x, y, Math.random() > 0.1 ? BGR_DEAD & 0x00ffffff : BGR_ALIVE | 0xff000000);\n    }\n  }\n}\n\n/** Performs one step. Called about 30 times a second from JS. */\nexport function step(): void {\n  var hm1 = h - 1, // h - 1\n      wm1 = w - 1; // w - 1\n\n  // The universe of the Game of Life is an infinite two-dimensional orthogonal grid of square\n  // \"cells\", each of which is in one of two possible states, alive or dead.\n  for (let y = 0; y < h; ++y) {\n    let ym1 = y == 0 ? hm1 : y - 1,\n        yp1 = y == hm1 ? 0 : y + 1;\n    for (let x = 0; x < w; ++x) {\n      let xm1 = x == 0 ? wm1 : x - 1,\n          xp1 = x == wm1 ? 0 : x + 1;\n\n      // Every cell interacts with its eight neighbours, which are the cells that are horizontally,\n      // vertically, or diagonally adjacent. Least significant bit indicates alive or dead.\n      let aliveNeighbors = (\n        (get(xm1, ym1) & 1) + (get(x  , ym1) & 1) + (get(xp1, ym1) & 1) +\n        (get(xm1, y  ) & 1)                       + (get(xp1, y  ) & 1) +\n        (get(xm1, yp1) & 1) + (get(x  , yp1) & 1) + (get(xp1, yp1) & 1)\n      );\n\n      let self = get(x, y);\n      if (self & 1) {\n        // A live cell with 2 or 3 live neighbors rots on to the next generation.\n        if ((aliveNeighbors & 0b1110) == 0b0010) rot(x, y, self);\n        // A live cell with fewer than 2 or more than 3 live neighbors dies.\n        else set(x, y, BGR_DEAD | 0xff000000);\n      } else {\n        // A dead cell with exactly 3 live neighbors becomes a live cell.\n        if (aliveNeighbors == 3) set(x, y, BGR_ALIVE | 0xff000000);\n        // A dead cell with fewer or more than 3 live neighbors just rots.\n        else rot(x, y, self);\n      }\n    }\n  }\n}\n\n/** Fills the row and column indicated by `x` and `y` with random live cells. */\nexport function fill(x: u32, y: u32, p: f64): void {\n  for (let ix = 0; ix < w; ++ix) {\n    if (Math.random() < p) set(ix, y, BGR_ALIVE | 0xff000000);\n  }\n  for (let iy = 0; iy < h; ++iy) {\n    if (Math.random() < p) set(x, iy, BGR_ALIVE | 0xff000000);\n  }\n}\n"]}